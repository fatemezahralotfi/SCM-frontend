{"ast":null,"code":"/*\n * Copyright 2012-2016 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n'use strict';\n\nvar defaultClient, mixin, responsePromise, client;\ndefaultClient = require('./client/default');\nmixin = require('./util/mixin');\nresponsePromise = require('./util/responsePromise');\nclient = require('./client');\n/**\n * Interceptors have the ability to intercept the request and/org response\n * objects.  They may augment, prune, transform or replace the\n * request/response as needed.  Clients may be composed by wrapping\n * together multiple interceptors.\n *\n * Configured interceptors are functional in nature.  Wrapping a client in\n * an interceptor will not affect the client, merely the data that flows in\n * and out of that client.  A common configuration can be created once and\n * shared; specialization can be created by further wrapping that client\n * with custom interceptors.\n *\n * @param {Client} [target] client to wrap\n * @param {Object} [config] configuration for the interceptor, properties will be specific to the interceptor implementation\n * @returns {Client} A client wrapped with the interceptor\n *\n * @class Interceptor\n */\n\nfunction defaultInitHandler(config) {\n  return config;\n}\n\nfunction defaultRequestHandler(request\n/*, config, meta */\n) {\n  return request;\n}\n\nfunction defaultResponseHandler(response\n/*, config, meta */\n) {\n  return response;\n}\n/**\n * Alternate return type for the request handler that allows for more complex interactions.\n *\n * @param properties.request the traditional request return object\n * @param {Promise} [properties.abort] promise that resolves if/when the request is aborted\n * @param {Client} [properties.client] override the defined client with an alternate client\n * @param [properties.response] response for the request, short circuit the request\n */\n\n\nfunction ComplexRequest(properties) {\n  if (!(this instanceof ComplexRequest)) {\n    // in case users forget the 'new' don't mix into the interceptor\n    return new ComplexRequest(properties);\n  }\n\n  mixin(this, properties);\n}\n/**\n * Create a new interceptor for the provided handlers.\n *\n * @param {Function} [handlers.init] one time intialization, must return the config object\n * @param {Function} [handlers.request] request handler\n * @param {Function} [handlers.response] response handler regardless of error state\n * @param {Function} [handlers.success] response handler when the request is not in error\n * @param {Function} [handlers.error] response handler when the request is in error, may be used to 'unreject' an error state\n * @param {Function} [handlers.client] the client to use if otherwise not specified, defaults to platform default client\n *\n * @returns {Interceptor}\n */\n\n\nfunction interceptor(handlers) {\n  var initHandler, requestHandler, successResponseHandler, errorResponseHandler;\n  handlers = handlers || {};\n  initHandler = handlers.init || defaultInitHandler;\n  requestHandler = handlers.request || defaultRequestHandler;\n  successResponseHandler = handlers.success || handlers.response || defaultResponseHandler;\n\n  errorResponseHandler = handlers.error || function () {\n    // Propagate the rejection, with the result of the handler\n    return Promise.resolve((handlers.response || defaultResponseHandler).apply(this, arguments)).then(Promise.reject.bind(Promise));\n  };\n\n  return function (target, config) {\n    if (typeof target === 'object') {\n      config = target;\n    }\n\n    if (typeof target !== 'function') {\n      target = handlers.client || defaultClient;\n    }\n\n    config = initHandler(config || {});\n\n    function interceptedClient(request) {\n      var context, meta;\n      context = {};\n      meta = {\n        'arguments': Array.prototype.slice.call(arguments),\n        client: interceptedClient\n      };\n      request = typeof request === 'string' ? {\n        path: request\n      } : request || {};\n      request.originator = request.originator || interceptedClient;\n      return responsePromise(requestHandler.call(context, request, config, meta), function (request) {\n        var response, abort, next;\n        next = target;\n\n        if (request instanceof ComplexRequest) {\n          // unpack request\n          abort = request.abort;\n          next = request.client || next;\n          response = request.response; // normalize request, must be last\n\n          request = request.request;\n        }\n\n        response = response || Promise.resolve(request).then(function (request) {\n          return Promise.resolve(next(request)).then(function (response) {\n            return successResponseHandler.call(context, response, config, meta);\n          }, function (response) {\n            return errorResponseHandler.call(context, response, config, meta);\n          });\n        });\n        return abort ? Promise.race([response, abort]) : response;\n      }, function (error) {\n        return Promise.reject({\n          request: request,\n          error: error\n        });\n      });\n    }\n\n    return client(interceptedClient, target);\n  };\n}\n\ninterceptor.ComplexRequest = ComplexRequest;\nmodule.exports = interceptor;","map":{"version":3,"sources":["/Users/fatemezahralotfi/IdeaProjects/SCM-frontend/node_modules/rest/interceptor.js"],"names":["defaultClient","mixin","responsePromise","client","require","defaultInitHandler","config","defaultRequestHandler","request","defaultResponseHandler","response","ComplexRequest","properties","interceptor","handlers","initHandler","requestHandler","successResponseHandler","errorResponseHandler","init","success","error","Promise","resolve","apply","arguments","then","reject","bind","target","interceptedClient","context","meta","Array","prototype","slice","call","path","originator","abort","next","race","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,IAAIA,aAAJ,EAAmBC,KAAnB,EAA0BC,eAA1B,EAA2CC,MAA3C;AAEAH,aAAa,GAAGI,OAAO,CAAC,kBAAD,CAAvB;AACAH,KAAK,GAAGG,OAAO,CAAC,cAAD,CAAf;AACAF,eAAe,GAAGE,OAAO,CAAC,wBAAD,CAAzB;AACAD,MAAM,GAAGC,OAAO,CAAC,UAAD,CAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,kBAAT,CAA4BC,MAA5B,EAAoC;AACnC,SAAOA,MAAP;AACA;;AAED,SAASC,qBAAT,CAA+BC;AAAQ;AAAvC,EAA4D;AAC3D,SAAOA,OAAP;AACA;;AAED,SAASC,sBAAT,CAAgCC;AAAS;AAAzC,EAA8D;AAC7D,SAAOA,QAAP;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,cAAT,CAAwBC,UAAxB,EAAoC;AACnC,MAAI,EAAE,gBAAgBD,cAAlB,CAAJ,EAAuC;AACtC;AACA,WAAO,IAAIA,cAAJ,CAAmBC,UAAnB,CAAP;AACA;;AACDX,EAAAA,KAAK,CAAC,IAAD,EAAOW,UAAP,CAAL;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,WAAT,CAAqBC,QAArB,EAA+B;AAE9B,MAAIC,WAAJ,EAAiBC,cAAjB,EAAiCC,sBAAjC,EAAyDC,oBAAzD;AAEAJ,EAAAA,QAAQ,GAAGA,QAAQ,IAAI,EAAvB;AAEAC,EAAAA,WAAW,GAAcD,QAAQ,CAACK,IAAT,IAAoBd,kBAA7C;AACAW,EAAAA,cAAc,GAAWF,QAAQ,CAACN,OAAT,IAAoBD,qBAA7C;AACAU,EAAAA,sBAAsB,GAAGH,QAAQ,CAACM,OAAT,IAAoBN,QAAQ,CAACJ,QAA7B,IAAyCD,sBAAlE;;AACAS,EAAAA,oBAAoB,GAAKJ,QAAQ,CAACO,KAAT,IAAoB,YAAY;AACxD;AACA,WAAOC,OAAO,CAACC,OAAR,CAAgB,CAACT,QAAQ,CAACJ,QAAT,IAAqBD,sBAAtB,EAA8Ce,KAA9C,CAAoD,IAApD,EAA0DC,SAA1D,CAAhB,EACLC,IADK,CACAJ,OAAO,CAACK,MAAR,CAAeC,IAAf,CAAoBN,OAApB,CADA,CAAP;AAEA,GAJD;;AAMA,SAAO,UAAUO,MAAV,EAAkBvB,MAAlB,EAA0B;AAEhC,QAAI,OAAOuB,MAAP,KAAkB,QAAtB,EAAgC;AAC/BvB,MAAAA,MAAM,GAAGuB,MAAT;AACA;;AACD,QAAI,OAAOA,MAAP,KAAkB,UAAtB,EAAkC;AACjCA,MAAAA,MAAM,GAAGf,QAAQ,CAACX,MAAT,IAAmBH,aAA5B;AACA;;AAEDM,IAAAA,MAAM,GAAGS,WAAW,CAACT,MAAM,IAAI,EAAX,CAApB;;AAEA,aAASwB,iBAAT,CAA2BtB,OAA3B,EAAoC;AACnC,UAAIuB,OAAJ,EAAaC,IAAb;AACAD,MAAAA,OAAO,GAAG,EAAV;AACAC,MAAAA,IAAI,GAAG;AAAE,qBAAaC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BX,SAA3B,CAAf;AAAsDtB,QAAAA,MAAM,EAAE2B;AAA9D,OAAP;AACAtB,MAAAA,OAAO,GAAG,OAAOA,OAAP,KAAmB,QAAnB,GAA8B;AAAE6B,QAAAA,IAAI,EAAE7B;AAAR,OAA9B,GAAkDA,OAAO,IAAI,EAAvE;AACAA,MAAAA,OAAO,CAAC8B,UAAR,GAAqB9B,OAAO,CAAC8B,UAAR,IAAsBR,iBAA3C;AACA,aAAO5B,eAAe,CACrBc,cAAc,CAACoB,IAAf,CAAoBL,OAApB,EAA6BvB,OAA7B,EAAsCF,MAAtC,EAA8C0B,IAA9C,CADqB,EAErB,UAAUxB,OAAV,EAAmB;AAClB,YAAIE,QAAJ,EAAc6B,KAAd,EAAqBC,IAArB;AACAA,QAAAA,IAAI,GAAGX,MAAP;;AACA,YAAIrB,OAAO,YAAYG,cAAvB,EAAuC;AACtC;AACA4B,UAAAA,KAAK,GAAG/B,OAAO,CAAC+B,KAAhB;AACAC,UAAAA,IAAI,GAAGhC,OAAO,CAACL,MAAR,IAAkBqC,IAAzB;AACA9B,UAAAA,QAAQ,GAAGF,OAAO,CAACE,QAAnB,CAJsC,CAKtC;;AACAF,UAAAA,OAAO,GAAGA,OAAO,CAACA,OAAlB;AACA;;AACDE,QAAAA,QAAQ,GAAGA,QAAQ,IAAIY,OAAO,CAACC,OAAR,CAAgBf,OAAhB,EAAyBkB,IAAzB,CAA8B,UAAUlB,OAAV,EAAmB;AACvE,iBAAOc,OAAO,CAACC,OAAR,CAAgBiB,IAAI,CAAChC,OAAD,CAApB,EAA+BkB,IAA/B,CACN,UAAUhB,QAAV,EAAoB;AACnB,mBAAOO,sBAAsB,CAACmB,IAAvB,CAA4BL,OAA5B,EAAqCrB,QAArC,EAA+CJ,MAA/C,EAAuD0B,IAAvD,CAAP;AACA,WAHK,EAIN,UAAUtB,QAAV,EAAoB;AACnB,mBAAOQ,oBAAoB,CAACkB,IAArB,CAA0BL,OAA1B,EAAmCrB,QAAnC,EAA6CJ,MAA7C,EAAqD0B,IAArD,CAAP;AACA,WANK,CAAP;AAQA,SATsB,CAAvB;AAUA,eAAOO,KAAK,GAAGjB,OAAO,CAACmB,IAAR,CAAa,CAAC/B,QAAD,EAAW6B,KAAX,CAAb,CAAH,GAAqC7B,QAAjD;AACA,OAxBoB,EAyBrB,UAAUW,KAAV,EAAiB;AAChB,eAAOC,OAAO,CAACK,MAAR,CAAe;AAAEnB,UAAAA,OAAO,EAAEA,OAAX;AAAoBa,UAAAA,KAAK,EAAEA;AAA3B,SAAf,CAAP;AACA,OA3BoB,CAAtB;AA6BA;;AAED,WAAOlB,MAAM,CAAC2B,iBAAD,EAAoBD,MAApB,CAAb;AACA,GAjDD;AAkDA;;AAEDhB,WAAW,CAACF,cAAZ,GAA6BA,cAA7B;AAEA+B,MAAM,CAACC,OAAP,GAAiB9B,WAAjB","sourcesContent":["/*\n * Copyright 2012-2016 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n'use strict';\n\nvar defaultClient, mixin, responsePromise, client;\n\ndefaultClient = require('./client/default');\nmixin = require('./util/mixin');\nresponsePromise = require('./util/responsePromise');\nclient = require('./client');\n\n/**\n * Interceptors have the ability to intercept the request and/org response\n * objects.  They may augment, prune, transform or replace the\n * request/response as needed.  Clients may be composed by wrapping\n * together multiple interceptors.\n *\n * Configured interceptors are functional in nature.  Wrapping a client in\n * an interceptor will not affect the client, merely the data that flows in\n * and out of that client.  A common configuration can be created once and\n * shared; specialization can be created by further wrapping that client\n * with custom interceptors.\n *\n * @param {Client} [target] client to wrap\n * @param {Object} [config] configuration for the interceptor, properties will be specific to the interceptor implementation\n * @returns {Client} A client wrapped with the interceptor\n *\n * @class Interceptor\n */\n\nfunction defaultInitHandler(config) {\n\treturn config;\n}\n\nfunction defaultRequestHandler(request /*, config, meta */) {\n\treturn request;\n}\n\nfunction defaultResponseHandler(response /*, config, meta */) {\n\treturn response;\n}\n\n/**\n * Alternate return type for the request handler that allows for more complex interactions.\n *\n * @param properties.request the traditional request return object\n * @param {Promise} [properties.abort] promise that resolves if/when the request is aborted\n * @param {Client} [properties.client] override the defined client with an alternate client\n * @param [properties.response] response for the request, short circuit the request\n */\nfunction ComplexRequest(properties) {\n\tif (!(this instanceof ComplexRequest)) {\n\t\t// in case users forget the 'new' don't mix into the interceptor\n\t\treturn new ComplexRequest(properties);\n\t}\n\tmixin(this, properties);\n}\n\n/**\n * Create a new interceptor for the provided handlers.\n *\n * @param {Function} [handlers.init] one time intialization, must return the config object\n * @param {Function} [handlers.request] request handler\n * @param {Function} [handlers.response] response handler regardless of error state\n * @param {Function} [handlers.success] response handler when the request is not in error\n * @param {Function} [handlers.error] response handler when the request is in error, may be used to 'unreject' an error state\n * @param {Function} [handlers.client] the client to use if otherwise not specified, defaults to platform default client\n *\n * @returns {Interceptor}\n */\nfunction interceptor(handlers) {\n\n\tvar initHandler, requestHandler, successResponseHandler, errorResponseHandler;\n\n\thandlers = handlers || {};\n\n\tinitHandler            = handlers.init    || defaultInitHandler;\n\trequestHandler         = handlers.request || defaultRequestHandler;\n\tsuccessResponseHandler = handlers.success || handlers.response || defaultResponseHandler;\n\terrorResponseHandler   = handlers.error   || function () {\n\t\t// Propagate the rejection, with the result of the handler\n\t\treturn Promise.resolve((handlers.response || defaultResponseHandler).apply(this, arguments))\n\t\t\t.then(Promise.reject.bind(Promise));\n\t};\n\n\treturn function (target, config) {\n\n\t\tif (typeof target === 'object') {\n\t\t\tconfig = target;\n\t\t}\n\t\tif (typeof target !== 'function') {\n\t\t\ttarget = handlers.client || defaultClient;\n\t\t}\n\n\t\tconfig = initHandler(config || {});\n\n\t\tfunction interceptedClient(request) {\n\t\t\tvar context, meta;\n\t\t\tcontext = {};\n\t\t\tmeta = { 'arguments': Array.prototype.slice.call(arguments), client: interceptedClient };\n\t\t\trequest = typeof request === 'string' ? { path: request } : request || {};\n\t\t\trequest.originator = request.originator || interceptedClient;\n\t\t\treturn responsePromise(\n\t\t\t\trequestHandler.call(context, request, config, meta),\n\t\t\t\tfunction (request) {\n\t\t\t\t\tvar response, abort, next;\n\t\t\t\t\tnext = target;\n\t\t\t\t\tif (request instanceof ComplexRequest) {\n\t\t\t\t\t\t// unpack request\n\t\t\t\t\t\tabort = request.abort;\n\t\t\t\t\t\tnext = request.client || next;\n\t\t\t\t\t\tresponse = request.response;\n\t\t\t\t\t\t// normalize request, must be last\n\t\t\t\t\t\trequest = request.request;\n\t\t\t\t\t}\n\t\t\t\t\tresponse = response || Promise.resolve(request).then(function (request) {\n\t\t\t\t\t\treturn Promise.resolve(next(request)).then(\n\t\t\t\t\t\t\tfunction (response) {\n\t\t\t\t\t\t\t\treturn successResponseHandler.call(context, response, config, meta);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfunction (response) {\n\t\t\t\t\t\t\t\treturn errorResponseHandler.call(context, response, config, meta);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\treturn abort ? Promise.race([response, abort]) : response;\n\t\t\t\t},\n\t\t\t\tfunction (error) {\n\t\t\t\t\treturn Promise.reject({ request: request, error: error });\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\treturn client(interceptedClient, target);\n\t};\n}\n\ninterceptor.ComplexRequest = ComplexRequest;\n\nmodule.exports = interceptor;\n"]},"metadata":{},"sourceType":"script"}